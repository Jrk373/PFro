---
title: "Peer and Family Run Organizational Activity in Northern Arizona"
author: 
  name: "John Ryan Kivela, MA"
  email: "Ryan.Kivela@narbha.org"
  affiliation: "The Alliance ACO"
date: today
date-format: long
format:
  html:
    theme: pulse
    embed-resources: true
    toc: true
    toc-depth: 6
    code-fold: true
    footnotes-hover: true
---

```{r}
#| label: Setup
#| include: true
#| echo: false
#| warning: false
#| error: false

## Load Libraries
library(tidyverse)
library(readxl)
library(reprex)
library(knitr)
library(kableExtra)

# table for inline code
InLineCode <- data.frame(
  Test = "test"
  )

AZ_County_Map <- (c("Apache", "Coconino", "Mohave", "Navajo", "Yavapai"))
Provider_ShortName <- (c("CBI", "CPIH", "EHS", "LCBHC", "MMHC", "SHG", "SBH", "TGC", "WYGC"))

data("county.map")
```

# Introduction

The Alliance is researching the prevalence and impact of Peer and Family Run Organizations (PFros) on members of the alliance. The results of this research will drive future decision making as we incorporate Peer and Family Run Organizations (PFro) into the Alliance ACO. 

# Method

Basic strategy

Key Indicators

Things we looked at
-   A
-   B

# Data Preparation

First we extracted all claims for the 2022 VBP Measurement Year (1/1/2022-12/31/2022) from the BCBSAZ-Health Choice data warehouse that were delivered by key PFros in the Health Choice network.This data was extracted on 7/27/23.

```{sql}
#| label: BH Claims Pull
#| eval: false
#| include: true
#| echo: true
#| warning: false
#| error: false


-- Declare start and end variables
DECLARE @start DATE = '2022-01-22';
DECLARE @end DATE = '2022-12-31';
-- This is some sql code that extracts all claims by specific PFros, as outlined by NPI below.

-- Check if the temporary table exists and drop it if it does
IF OBJECT_ID('tempdb..#ValueSetListMy2023') IS NOT NULL
    DROP TABLE #ValueSetListMy2023;

-- Create a temporary table
CREATE TABLE #ValueSetListMy2023 (Code VARCHAR(100) COLLATE SQL_Latin1_General_CP1_CI_AS);

-- Insert values into the temporary table
INSERT INTO #ValueSetListMy2023 (Code)
VALUES ('1528415650'), ('1528415650'), ('1932373867'), ('1891969879'), ('1891969879'), ('1679747505'), ('1679747505'), ('1760656698'), ('1760656698'), ('1669646592'), ('1669646592'), ('1164799987'), ('1437599230'), ('1811454754'), ('1467751511'), ('1467751511'), ('1073935326'), ('1073935326'), ('1497815567'), ('1366884413'), ('1366884413'), ('1851735369'), ('1407257595'), ('1992816060');

-- Query to retrieve data from the claims.dbo.shcavos table
SELECT DISTINCT
	shcavos.primaryID, 
	id.BCBSMedicaidId AS MemberID,
	shcavos.AHCCCSID,
	shcavos.MemberCounty,
	shcavos.MemberZipCode,
	shcavos.MemberACCGSA,
	shcavos.ra,
	shcavos.begDate,
	shcavos.svccode,
	shcavos.ProviderName,
	shcavos.Placesvc,
	shcavos.ProviderType,
	shcavos.calcnetpd,
	shcavos.units,
	shcavos.PaySource,
	shcavos.PlanType,
	shcavos.AdmitDate,
	shcavos.DischargeDate,
	shcavos.RenderingProviderNpi,
	shcavos.RenderingProviderCounty,
	shcavos.RenderingProviderZipCode,
    shcavos.PrimaryDiagnosis,
    shcavos.Dx1,
    shcavos.Dx2,
    shcavos.Dx3,
    shcavos.Dx4,
    shcavos.Dx5,
    shcavos.Dx6,
    shcavos.Dx7,
    shcavos.Dx8,
    shcavos.Dx9,
    shcavos.Dx10,
    shcavos.Dx11,
    shcavos.Dx12,
    CASE WHEN v.Code IS NOT NULL THEN 'True' ELSE 'False' END AS MatchFound
FROM claims.dbo.shcavos AS shcavos
LEFT JOIN GlobalMembers.dbo.ClientIdPlus id ON shcavos.primaryID = id.primaryID
LEFT JOIN #ValueSetListMy2023 AS v ON shcavos.RenderingProviderNpi COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx1 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx2 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx3 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx4 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx5 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx6 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx7 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx8 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx9 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx10 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx11 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx12 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
WHERE shcavos.begDate BETWEEN @start AND @end
AND CASE WHEN v.Code IS NOT NULL THEN 'True' ELSE 'False' END = 'True'
AND shcavos.EncounterStatus = 'AP'
```

```{r}
#| label: Load PFro Claims
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Load the claims pull from HCA warehouse
PFroBHClaims <- read_xlsx ("./data/BHClaims.xlsx", sheet = "Sheet1")

# Rename the column
colnames(PFroBHClaims)[colnames(PFroBHClaims) == "begDate"] <- "DateOfService"
colnames(PFroBHClaims)[colnames(PFroBHClaims) == "calcnetpd"] <- "AmountPd"

```

Then we extracted the current member roster from BCBSAZ Health Choice data warehouse. This roster was pulled on 7/21/23. This original roster includes all HCA members in the Arizona ACC health plan.

```{sql}
#| label: Member Roster Pull
#| eval: false
#| include: true
#| echo: true
#| warning: false
#| error: false
-- This is the code to extract Alliance ACO members from HCA data warehouse
-- Updated 5/2/23 by JRK

SELECT dm.primaryId
	, dm.ahcccsId
	, cid.lastName
	, cid.firstName
	, cid.sex
	, cid.dob
	, cid.zipCode
	, da.resCountyName
	, dm.bhhShortname
	, dm.bhhEffectiveDate
	, dm.lineOfBusiness
	, dm.bhc
	, dm.disenrollmentDate


FROM 
globalMembers.dbo.dailyMembershipAllArizonaEnrollments dm
LEFT JOIN globalMembers.dbo.clientIdPlus cid ON dm.primaryId = cid.primaryId
LEFT JOIN globalMembers.dbo.dailyMembershipAllArizonaAddresses da ON dm.primaryId = da.primaryId

WHERE
dm.LineOfBusiness = 'ArizonaACC'
```

Then the Global Members Roster is filtered down to Alliance members only by filtering for residential addresses in the northern 5 counties, and auto-assignments to Alliance Providers.

```{r}
#| label: Load Global Members Roster
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false
 
GlblMmbrshp <- read_xlsx("./data/data_original_glblmbrs_2023-07-26_globalMembersRoster.xlsx", sheet = "Sheet1")

# Calculate active members based on BCBSAZ auto-enrollment
NAZMmbrshp <- GlblMmbrshp |> 
  #filter(disenrollmentDate == "NULL") |> 
  filter(resCountyName %in% AZ_County_Map) |>
  filter(bhhShortname %in% Provider_ShortName) |> 
  mutate(bhhShortname = 
           if_else((bhhShortname == "SBH"), "SBHS", 
              if_else((bhhShortname == "WYGC"), "PH", 
                bhhShortname)
           ))

```

Then we merge the Global Membership Roster with the PFro BH Claims records, attaching each BH claim to its respective member information.

```{r}
#| label: Merge Enrollment
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Rename the column "ahcccsId" to "AHCCCSID"
colnames(NAZMmbrshp)[colnames(NAZMmbrshp) == "ahcccsId"] <- "AHCCCSID"

# Merge the data frames
PFroActivity <- merge(x = NAZMmbrshp,
                      y = PFroBHClaims,
                      by = "AHCCCSID"
                      )

```

Now append the B2 Matrix description words for the svccodes, just to make it more easily readable.

```{r}
#| label: Append B2 Matrix data to table
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

B2MatrixDesc <- read_xlsx("./data/B2MatrixDescriptions.xlsx", sheet = "Sheet1")

# Rename the column 
colnames(B2MatrixDesc)[colnames(B2MatrixDesc) == "Code"] <- "svccode"

# Perform a left join to add "VBPQR$Measure" and "VBPQR$Gap.Status" to PFroActivity
PFroActivity <- merge(x = PFroActivity,
                      y = B2MatrixDesc,
                      by = "svccode",
                      all.x = TRUE)

```

Now add in indicators for ICD 10 diagnostic group ranges.

```{r}
#| label: Append Dx Group Range to table
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

ICD10DxAndGroupsCombined <- read_csv("./data/ICD10andBHGroupingsCombined.csv")

# Rename the column

colnames(ICD10DxAndGroupsCombined)[colnames(ICD10DxAndGroupsCombined) == "primaryDiagnosis"] <- "PrimaryDiagnosis"

PFroActivity <- merge(x = PFroActivity,
                      y = ICD10DxAndGroupsCombined,
                      by = "PrimaryDiagnosis",
                      all.x = TRUE)

```

Then import the aggregated HCA VBP Quality Roster. This allows us to identify those members who have been served by a PFro, who have also been deemed eligible for a VBP measure. This is taken from the 7/21/23 report. 

```{r}
#| label: Load VBP data
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

VBPQR <- read.csv("./data/VBPQR_AllAPsCombined_Cleaned_complete_2023-07-21.csv")

# Rename the column 
colnames(VBPQR)[colnames(VBPQR) == "Member.ID"] <- "MemberID"

```

Now we add additional columns to indicate any cases that have been identified by the VBP roster. We record the name of the VBP measure and its gap status per the HC VBPQR.

```{r}
#| label: Append VBP data to table
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# First AMM

# Create the new columns "isVBP_AMM" and "GapStatus_AMM" with default values
PFroActivity$isVBP_AMM <- NA
PFroActivity$GapStatus_AMM <- NA

# Check for matching MemberID and specific Measure, then assign values to the new columns
PFroActivity$isVBP_AMM <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & 
                                 VBPQR$Measure == "AMM - Antidepressant Medication Management - Effective Acute Phase Treatment – Total",
                                 "AMM", PFroActivity$isVBP_AMM)

PFroActivity$GapStatus_AMM <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & 
                                     VBPQR$Measure == "AMM - Antidepressant Medication Management - Effective Acute Phase Treatment – Total",
                                     VBPQR$Gap.Status, PFroActivity$GapStatus_AMM)

# Then FUH

# Create the new columns "isVBP_AMM" and "GapStatus_AMM" with default values
PFroActivity$isVBP_FUH <- NA
PFroActivity$GapStatus_FUH <- NA

# Check for matching MemberID and specific Measure, then assign values to the new columns
PFroActivity$isVBP_FUH <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & 
                                 VBPQR$Measure == "FUH - Follow-Up after Hospitalization for Mental Illness: 7 Day",
                                 "FUH", PFroActivity$isVBP_FUH)

PFroActivity$GapStatus_FUH <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & 
                                     VBPQR$Measure == "FUH - Follow-Up after Hospitalization for Mental Illness: 7 Day",
                                     VBPQR$Gap.Status, PFroActivity$GapStatus_FUH)

# Then HDO

# Create the new columns "isVBP_AMM" and "GapStatus_AMM" with default values
PFroActivity$isVBP_HDO <- NA
PFroActivity$GapStatus_HDO <- NA

# Check for matching MemberID and specific Measure, then assign values to the new columns
PFroActivity$isVBP_HDO <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & 
                                 VBPQR$Measure == "HDO - Use of Opioids at High Dosage",
                                 "HDO", PFroActivity$isVBP_HDO)

PFroActivity$GapStatus_HDO <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & 
                                     VBPQR$Measure == "HDO - Use of Opioids at High Dosage",
                                     VBPQR$Gap.Status, PFroActivity$GapStatus_HDO)

# Create the new column "isVBP" with default value "NotVBP"
PFroActivity$isVBP <- "NotVBP"

# Check if any of the isVBP_AMM, isVBP_FUH, or isVBP_HDO columns are not NA
# If any of them is not NA, assign "isVBP" to the "isVBP" column
PFroActivity$isVBP <- ifelse(!is.na(PFroActivity$isVBP_AMM) |
                              !is.na(PFroActivity$isVBP_FUH) |
                              !is.na(PFroActivity$isVBP_HDO),
                              "isVBP", PFroActivity$isVBP)

```

Next we use the FUH7 Validation (Inpatient Claims) data to check if any of the people identified so far had an eligible FUH7 inpatient claim according to HCA clams that have been approved and paid. The FUH7 data is for claims that were authorized and paid for the measurement year 2023-01-01 to 2023-12-31.

```{r}
#| label: Add inpatient indicator
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

IPClaims <- read_xlsx("./data/data_original_cat_2022-12-31_IPClaims.xlsx")

# Assuming PFroActivity and IPClaims are the names of your data frames

# Create a new column in PFroActivity called isIP
PFroActivity <- PFroActivity %>%
  mutate(
    isIP = ifelse(MemberID %in% IPClaims$MemberID, "IPClaim", "NoIP")
  )

```

Next we use the AMM Validation (PBM Claims) data to check if any of the people identified so far had an eligible AMM pharmacy claim according to HCA claims that have been approved and paid. The FUH7 data is for claims that were authorized and paid for the measurement year Intake Period 2021-05-01 to 2022-04-30.

```{r}
#| label: Add antidepressant med indicator
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

PBMClaims <- read_xlsx("./data/DataRaw_PBMClaims_2022-04-30.xlsx", sheet = "Sheet1")

# Rename the column 
colnames(PBMClaims)[colnames(PBMClaims) == "PrimaryId"] <- "primaryId"

# Create a new column in PFroActivity called isADMed
PFroActivity <- PFroActivity %>%
  mutate(
    isADMed = ifelse(primaryId %in% PBMClaims$primaryId, "ADMedClaim", "NoADMed")
  )
```

Finally, we select desired variables from this monster table into the final dataset, called PFroSummary. We also create a separate version with less variables, but filtered for only distinct MemberIDs by provider. 

```{r}
#| label: DIal in the data set
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Filter MemberACCGSA to only include "North" values
PFroActivity <- PFroActivity[PFroActivity$MemberACCGSA == "North", ]

# Now select the key variables for analysis
PFroSummary <- PFroActivity |> 
  select(
    MemberID,
    AHCCCSID,
    primaryId,
    ra,
    lastName,
    firstName,
    sex,
    dob,
    resCountyName,
    zipCode,
    DateOfService,
    svccode,
    Code_Description,
    ProviderName,
    ProviderType,
    Placesvc,
    units,
    AmountPd,
    PrimaryDiagnosis,
    ICD10_Description,
    DiagnosisGroupRange,
    Diagnosis_Group,
    isVBP,
    isVBP_AMM,
    GapStatus_AMM,
    isVBP_FUH,
    GapStatus_FUH,
    isVBP_HDO,
    GapStatus_HDO,
    isIP,
    isADMed
  )

# Write to CSV
write.csv(PFroSummary, "./data/output/PFroSummary.csv")

```

```{r}
#| label: Create unduplicated roster by provider
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# New version copied from PFroSummary
PFroSummary_Distinct_byProvider <- PFroActivity |> 
  select(
    MemberID,
    AHCCCSID,
    primaryId,
    ra,
    lastName,
    firstName,
    sex,
    dob,
    resCountyName,
    zipCode,
    ProviderName,
    isVBP,
    isVBP_AMM,
    GapStatus_AMM,
    isVBP_FUH,
    GapStatus_FUH,
    isVBP_HDO,
    GapStatus_HDO,
    isIP,
    isADMed
  )

# Filter for distinct MEmberID
PFroSummary_Distinct_byProvider <- PFroSummary_Distinct_byProvider %>%
  distinct(MemberID, .keep_all = TRUE)

# Write to CSV
write.csv(PFroSummary_Distinct_byProvider, "./data/output/PFroSummary_Distinct_byProvider.csv")

```

# Analysis

## Figure 1: PFro Services by Provider

The first view of this data is a visualization of the percent of total services delivered to HC members by each PFro. THis was filtered to only include service codes that accounted for at least 1% of the total.

```{r}
#| label: First Plot
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false


# Calculate the count of svccode by ProviderName
provider_svccode_counts <- PFroSummary %>%
  count(ProviderName, svccode)

# Calculate the grand total count of svccode
grand_total <- sum(provider_svccode_counts$n)

# Calculate the percentage of count for each svccode by ProviderName
provider_svccode_counts <- provider_svccode_counts %>%
  group_by(ProviderName) %>%
  mutate(Percentage = (n / grand_total) * 100)

# Filter to keep only svccodes accounting for at least 1% of the grand total
provider_svccode_counts_filtered <- provider_svccode_counts %>%
  filter(Percentage >= 1)

# Create the custom color palette with dark red, orange, dark green, and navy
custom_colors <- c("#8B0000", "#FFA500", "#006400", "#000080")

# Create the chart with svccode on the y-axis and the count as a percentage of the grand total on the x-axis, clustered by ProviderName with custom colors
ggplot(provider_svccode_counts_filtered, aes(x = Percentage, y = svccode, fill = ProviderName)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "PFro Services by Provider",
       subtitle = "As percent of grand total",
       x = "Percentage", 
       y = "svccode") +
  theme_minimal() +
  scale_x_continuous(labels = scales::percent_format(scale = 1)) +
  scale_fill_manual(values = custom_colors)


```

## Table 1: PFro Services by Provider

The first table is a summary of the services provided, and the amount that was paid to the provider.

```{r}
#| label: First Table
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Calculate the count of Code_Description by ProviderName and svccode
code_prov_counts <- PFroSummary %>%
  group_by(Code_Description, ProviderName, svccode) %>%
  tally() %>%
  ungroup()

# Calculate the total count of Code_Description
total_count <- sum(code_prov_counts$n)

# Calculate the percentage of count for each Code_Description
code_prov_counts <- code_prov_counts %>%
  group_by(Code_Description) %>%
  mutate(Percentage_of_Grand_Total = (n / total_count) * 100)

# Filter to keep only Code_Description rows representing at least 1% of the grand total
code_prov_counts_filtered <- code_prov_counts %>%
  filter(Percentage_of_Grand_Total >= 1)

# Reorder the columns to have ProviderName first, followed by svccode
code_prov_counts_filtered <- code_prov_counts_filtered %>%
  select(ProviderName, svccode, Code_Description, Percentage_of_Grand_Total)

# Sort the table by ProviderName in ascending order
code_prov_counts_filtered <- code_prov_counts_filtered %>%
  arrange(ProviderName)

# Summarize the AmountPd column to get the sum of Amount Paid for each Code_Description by ProviderName
amount_paid_sum <- PFroSummary %>%
  filter(Code_Description %in% code_prov_counts_filtered$Code_Description) %>%
  group_by(Code_Description, ProviderName) %>%
  summarise(Sum_AmountPd = sum(AmountPd))

# Join the summarized Amount Paid data with the filtered table
code_prov_counts_filtered <- left_join(code_prov_counts_filtered, amount_paid_sum, by = c("Code_Description", "ProviderName"))

# Format the Percentage_of_Grand_Total column with two decimal places and a "%" symbol
code_prov_counts_filtered$Percentage_of_Grand_Total <- sprintf("%.2f%%", code_prov_counts_filtered$Percentage_of_Grand_Total)

# Format the Sum_AmountPd column with a "$" sign and no decimal places
code_prov_counts_filtered$Sum_AmountPd <- paste0("$", round(code_prov_counts_filtered$Sum_AmountPd, 0))

# Display the table using kable
kable(code_prov_counts_filtered, format = "html", caption = "Summary of Services by ProviderName")


```

## Figure 2 (beta)
```{r}
#| label: First Plot (beta)
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false


# Calculate the count of svccode by ProviderName
sum_by_provider <- PFroSummary %>%
  group_by(ProviderName, svccode) %>%
  summarise(Total_AmountPd = sum(AmountPd))

# Calculate the grand total count of svccode
grand_total <- sum(sum_by_provider$Total_AmountPd)

# Calculate the pTotal_AmountPdfor each svccode by ProviderName
sum_by_provider <- sum_by_provider %>%
  group_by(ProviderName) %>%
  mutate(Percentage = (Total_AmountPd / grand_total) * 100)

# Filter to keep only svccodes accounting for at least 1% of the grand total
provider_svccode_counts_filtered <- sum_by_provider %>%
  filter(Percentage >= 1)

# Create the custom color palette with dark red, orange, dark green, and navy
custom_colors <- c("#8B0000", "#FFA500", "#006400", "#000080", "purple")

# Create the chart with svccode on the y-axis and the count as a percentage of the grand total on the x-axis, clustered by ProviderName with custom colors
ggplot(provider_svccode_counts_filtered, aes(x = Percentage, y = svccode, fill = ProviderName)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "PFro Services Paid by Provider",
       subtitle = "As percent of grand total",
       x = "Percentage", 
       y = "svccode") +
  theme_minimal() +
  scale_x_continuous(labels = scales::percent_format(scale = 1)) +
  scale_fill_manual(values = custom_colors)
```

## Figure 2

The following figure assesses how many HCA members in services with a PFro have been deemed eligible for a VBP measure. For this assessment, T1016 (Case Management) was excluded.

```{r}
#| label: Distinct Members
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Assuming PFroSummary is your data frame

# Calculate the count of distinct MemberID for each ProviderName and isVBP combination
stacked_data <- PFroSummary %>%
  filter(svccode != "T1016") |>
  group_by(ProviderName, isVBP) %>%
  summarise(count = n_distinct(MemberID))

# Create the stacked bar chart with x and y-axis flipped
ggplot(stacked_data, aes(x = count, y = ProviderName, fill = isVBP)) +
  geom_bar(stat = "identity") +
  labs(title = "Current PFro Engagement with VBP Eligible Members",
       subtitle = "T1016 Removed",
       x = "Count of Distinct MemberID",
       y = "ProviderName",
       fill = "VBP Eligibility") +
  theme_minimal() +
  theme(axis.text.y = element_text(hjust = 0))  # Adjust the position of y-axis labels

```

```{r}
#| label: Second Table
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Filter out rows where svccode is "T1016"
PFroSummary_filtered <- PFroSummary %>%
  filter(svccode != "T1016")

# Calculate the count of distinct MemberID for each ProviderName and isVBP combination
summary_table <- PFroSummary_filtered %>%
  group_by(ProviderName, isVBP) %>%
  summarise(Count_of_Distinct_MemberID = n_distinct(MemberID)) %>%
  ungroup() %>%
  group_by(ProviderName) %>%
  mutate(Total_by_Provider = sum(Count_of_Distinct_MemberID),
         `Percent of Total per Provider` = (Count_of_Distinct_MemberID / Total_by_Provider) * 100) %>%
  select(-Total_by_Provider) # Remove the intermediate column

# Format the "Percent of Total per Provider" column to have 2 decimal places
summary_table$`Percent of Total per Provider` <- sprintf("%.2f%%", summary_table$`Percent of Total per Provider`)

# Calculate the grand total
grand_total <- n_distinct(PFroSummary_filtered$MemberID)

# Calculate the percent of grand total for each ProviderName
summary_table$`Percent of Grand Total` <- sprintf("%.2f%%", (summary_table$Count_of_Distinct_MemberID / grand_total) * 100)

kable(summary_table)


```

```{r}
#| label: County
#| eval: false
#| include: true
#| echo: true
#| warning: false
#| error: false

# Filter out rows where svccode is "T1016"
PFroSummary_filtered <- PFroSummary %>%
  filter(svccode != "T1016")

# Create a summary table by resCountyName and ProviderName
summary_table <- PFroSummary_filtered %>%
  group_by(resCountyName, ProviderName) %>%
  summarise(Count_of_Distinct_MemberID = n_distinct(MemberID)) %>%
  ungroup()

# Sort the resCountyName based on the count of MemberIDs in descending order
summary_table <- summary_table %>%
  arrange(resCountyName, desc(Count_of_Distinct_MemberID))

# Create the stacked bar chart with flipped axes and sorted bars
p <- ggplot(data = summary_table, aes(x = fct_reorder(resCountyName, Count_of_Distinct_MemberID, .fun = sum), y = Count_of_Distinct_MemberID, fill = ProviderName)) +
  geom_bar(stat = "identity") +
  labs(title = "Number of MemberIDs by County and Provider (Excluding T1016)",
       subtitle = "T1016 Removed",
       x = "County",
       y = "Number of MemberIDs") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  guides(fill = guide_legend(title = "Provider Name")) +
  coord_flip()

# Print the plot
print(p)

```

Make a choropleth map

```{r}
#| label: Map
#| eval: false
#| include: false
#| echo: false
#| warning: false
#| error: false


# Load the zip code data for mapping
# Replace "path_to_zip_code_data" with the actual path to your zip code data file
# The file should contain columns "region" (zip code) and "subregion" (name of the area)
zip_codes_data <- read.csv("./data/data_reference_zip_code_database.csv")

# Calculate the count of occurrences for each zip code in PFroSummary data
zip_counts <- PFroSummary %>%
  group_by(zipCode) %>%
  tally()

# Load the zip code data for Arizona
arizona_zip_codes_data <- zip_codes_data %>%
  filter(state == "AZ")

# Rename the "zipCode" column in zip_counts to "region" for consistency
zip_counts <- zip_counts %>%
  rename(region = zipCode)

# Rename the "zip" column in arizona zip coes data to "region" for consistency
arizona_zip_codes_data <- arizona_zip_codes_data %>%
  rename(region = zip)

# Merge the zip code data for Arizona with the counts
merged_data <- merge(arizona_zip_codes_data, zip_counts, by = "region", all.x = TRUE)

# Create the choropleth map
ggplot(merged_data, aes(x = longitude, y = latitude, group = "region", fill = n)) +
  geom_polygon(color = "blue", size = 0.2) +
  coord_fixed() +
  labs(title = "Choropleth Map of Zip Code Counts in Arizona",
       subtitle = "Counts of occurrences for each zip code",
       fill = "n") +
  theme_minimal() +
  theme(legend.position = "bottom") +
  scale_fill_viridis_c()
    PrimaryDiagnosis,
    DiagnosisGroupRange,
    Diagnosis_Group,
    isVBPQR,
    Measure,
    Gap.Status
  )

write.csv(PFroSummary, "./data/PFroSummary.csv")


```