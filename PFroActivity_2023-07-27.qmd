---
title: "Peer and Family Run Organizational Activity in Northern Arizona"
author: 
  name: "John Ryan Kivela, MA"
  email: "Ryan.Kivela@narbha.org"
  affiliation: "The Alliance ACO"
date: today
date-format: long
format:
  html:
    theme: pulse
    embed-resources: true
    toc: true
    toc-depth: 6
    code-fold: true
    footnotes-hover: true
---

```{r}
#| label: Setup
#| include: true
#| echo: false
#| warning: false
#| error: false

## Load Libraries
library(tidyverse)
library(readxl)
library(reprex)
library(knitr)
library(kableExtra)
library(scales)
library(tidyr)

# table for inline code
InLineCode <- data.frame(
  Member_Report_Date = "July 27, 2023"
  )

AZ_County_Map <- (c("Apache", "Coconino", "Mohave", "Navajo", "Yavapai"))
Provider_ShortName <- (c("CBI", "CPIH", "EHS", "LCBHC", "MMHC", "SHG", "SBH", "TGC", "WYGC"))

data("county.map")
```

# Introduction

The Alliance is researching the prevalence and impact of Peer and Family Run Organizations (PFros) on members of the alliance. The results of this research will drive future decision making as we incorporate Peer and Family Run Organizations (PFro) into the Alliance ACO.

# Method

Basic strategy

Key Indicators

Things we looked at - A - B

# Data Preparation

First we extracted all behavioral health claims for the 2022 VBP Measurement Year (1/1/2022-12/31/2022) from the BCBSAZ-Health Choice data warehouse that were delivered by key PFros in the Health Choice network.This data was extracted on 7/27/23.

```{sql}
#| label: BH Claims Pull
#| eval: false
#| include: true
#| echo: true
#| warning: false
#| error: false


-- Declare start and end variables
DECLARE @start DATE = '2022-01-22';
DECLARE @end DATE = '2022-12-31';
-- This is some sql code that extracts all claims by specific PFros, as outlined by NPI below.

-- Check if the temporary table exists and drop it if it does
IF OBJECT_ID('tempdb..#ValueSetListMy2023') IS NOT NULL
    DROP TABLE #ValueSetListMy2023;

-- Create a temporary table
CREATE TABLE #ValueSetListMy2023 (Code VARCHAR(100) COLLATE SQL_Latin1_General_CP1_CI_AS);

-- Insert values into the temporary table
INSERT INTO #ValueSetListMy2023 (Code)
VALUES ('1528415650'), ('1528415650'), ('1932373867'), ('1891969879'), ('1891969879'), ('1679747505'), ('1679747505'), ('1760656698'), ('1760656698'), ('1669646592'), ('1669646592'), ('1164799987'), ('1437599230'), ('1811454754'), ('1467751511'), ('1467751511'), ('1073935326'), ('1073935326'), ('1497815567'), ('1366884413'), ('1366884413'), ('1851735369'), ('1407257595'), ('1992816060');

-- Query to retrieve data from the claims.dbo.shcavos table
SELECT DISTINCT
	shcavos.primaryID, 
	id.BCBSMedicaidId AS MemberID,
	shcavos.AHCCCSID,
	shcavos.MemberCounty,
	shcavos.MemberZipCode,
	shcavos.MemberACCGSA,
	shcavos.ra,
	shcavos.begDate,
	shcavos.svccode,
	shcavos.ProviderName,
	shcavos.Placesvc,
	shcavos.ProviderType,
	shcavos.calcnetpd,
	shcavos.units,
	shcavos.PaySource,
	shcavos.PlanType,
	shcavos.AdmitDate,
	shcavos.DischargeDate,
	shcavos.RenderingProviderNpi,
	shcavos.RenderingProviderCounty,
	shcavos.RenderingProviderZipCode,
    shcavos.PrimaryDiagnosis,
    shcavos.Dx1,
    shcavos.Dx2,
    shcavos.Dx3,
    shcavos.Dx4,
    shcavos.Dx5,
    shcavos.Dx6,
    shcavos.Dx7,
    shcavos.Dx8,
    shcavos.Dx9,
    shcavos.Dx10,
    shcavos.Dx11,
    shcavos.Dx12,
    CASE WHEN v.Code IS NOT NULL THEN 'True' ELSE 'False' END AS MatchFound
FROM claims.dbo.shcavos AS shcavos
LEFT JOIN GlobalMembers.dbo.ClientIdPlus id ON shcavos.primaryID = id.primaryID
LEFT JOIN #ValueSetListMy2023 AS v ON shcavos.RenderingProviderNpi COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx1 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx2 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx3 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx4 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx5 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx6 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx7 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx8 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx9 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx10 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx11 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
                                    OR shcavos.Dx12 COLLATE SQL_Latin1_General_CP1_CI_AS = v.Code
WHERE shcavos.begDate BETWEEN @start AND @end
AND CASE WHEN v.Code IS NOT NULL THEN 'True' ELSE 'False' END = 'True'
AND shcavos.EncounterStatus = 'AP'
```

```{r}
#| label: Load PFro Claims
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Load the claims pull from HCA warehouse
PFroBHClaims <- read_xlsx ("./data/BHClaims.xlsx", sheet = "Sheet1")

# Rename the column
colnames(PFroBHClaims)[colnames(PFroBHClaims) == "begDate"] <- "DateOfService"
colnames(PFroBHClaims)[colnames(PFroBHClaims) == "calcnetpd"] <- "AmountPd"

PFroBHClaims <- PFroBHClaims |> 
  filter(MemberACCGSA == "North")

```

Then we extracted the current Alliance ACO member roster from BCBSAZ Health Choice data warehouse. This roster was pulled on 7/21/23. This original roster includes all HCA members in the Arizona ACC health plan.

```{sql}
#| label: Member Roster Pull
#| eval: false
#| include: true
#| echo: true
#| warning: false
#| error: false
-- This is the code to extract Alliance ACO members from HCA data warehouse
-- Updated 5/2/23 by JRK

SELECT dm.primaryId
	, dm.ahcccsId
	, cid.lastName
	, cid.firstName
	, cid.sex
	, cid.dob
	, cid.zipCode
	, da.resCountyName
	, dm.bhhShortname
	, dm.bhhEffectiveDate
	, dm.lineOfBusiness
	, dm.bhc
	, dm.disenrollmentDate


FROM 
globalMembers.dbo.dailyMembershipAllArizonaEnrollments dm
LEFT JOIN globalMembers.dbo.clientIdPlus cid ON dm.primaryId = cid.primaryId
LEFT JOIN globalMembers.dbo.dailyMembershipAllArizonaAddresses da ON dm.primaryId = da.primaryId

WHERE
dm.LineOfBusiness = 'ArizonaACC'
```

Then the Global Members Roster for the Alliance ACO is filtered down to Alliance members only by filtering for residential addresses in the northern 5 counties, and auto-assignments to Alliance Providers.

```{r}
#| label: Load Global Members Roster
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false
 
GlblMmbrshp <- read_xlsx("./data/data_original_glblmbrs_2023-07-26_globalMembersRoster.xlsx", sheet = "Sheet1")

# Calculate active members based on BCBSAZ auto-enrollment
NAZMmbrshp <- GlblMmbrshp |> 
  #filter(disenrollmentDate == "NULL") |> 
  filter(resCountyName %in% AZ_County_Map) |>
  filter(bhhShortname %in% Provider_ShortName) |>
  filter(disenrollmentDate == "NULL") |> 
  mutate(bhhShortname = 
           if_else((bhhShortname == "SBH"), "SBHS", 
              if_else((bhhShortname == "WYGC"), "PH", 
                bhhShortname)
           ))
NAZMmbrshp <- NAZMmbrshp |> 
mutate(Age = as.integer(difftime(Sys.Date(), dob, units = "days") / 365.25))

# Note: The number of members is higher (250K) than the usual (105K) because disenrolled members are NOT excluded. 

```

Then we merge the Global Membership Roster with the PFro BH Claims records, attaching each behavioral health claim to its respective member information.The resulting table is a list of actively enrolled Alliance Members with PFro BH Claims.

This now gives us all of the claims information, adn all of the enrollment information for Alliance Members that received a service from a PFro.

```{r}
#| label: Merge Enrollment
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Rename the column "ahcccsId" to "AHCCCSID"
colnames(NAZMmbrshp)[colnames(NAZMmbrshp) == "ahcccsId"] <- "AHCCCSID"

# Merge the data frames
PFroActivity <- merge(x = NAZMmbrshp,
                      y = PFroBHClaims,
                      by = "AHCCCSID"
                      )

```

Now append the Behavioral Health Services Matrix description words for the service codes, just to make it more easily readable.

```{r}
#| label: Append B2 Matrix data to table
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

B2MatrixDesc <- read_xlsx("./data/B2MatrixDescriptions.xlsx", sheet = "Sheet1")

# Rename the column 
colnames(B2MatrixDesc)[colnames(B2MatrixDesc) == "Code"] <- "svccode"

# Perform a left join to add "VBPQR$Measure" and "VBPQR$Gap.Status" to PFroActivity
PFroActivity <- merge(x = PFroActivity,
                      y = B2MatrixDesc,
                      by = "svccode",
                      all.x = TRUE)

```

Now add in indicators for ICD 10 diagnostic group ranges. The Alliance has previously conducted research that indicates Mood Disorder and Anxiety Disorder diagnostic group ranges are more predictive of negative health and system outcomes, like inpatient care and high cost claims.

```{r}
#| label: Append Dx Group Range to table
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

ICD10DxAndGroupsCombined <- read_csv("./data/ICD10andBHGroupingsCombined.csv")

# Rename the column

colnames(ICD10DxAndGroupsCombined)[colnames(ICD10DxAndGroupsCombined) == "primaryDiagnosis"] <- "PrimaryDiagnosis"

PFroActivity <- merge(x = PFroActivity,
                      y = ICD10DxAndGroupsCombined,
                      by = "PrimaryDiagnosis",
                      all.x = TRUE)

```

Then import the aggregated Health Choice VBP Quality Roster. The Alliance has thoroughly documented and tested a validation model for the NCQA/HEDIS FUH measure. One output of that project is an aggregated and cleaned roster containing all of the data from the Health Choice VBP Quality Rosters of ALL of the Alliance Providers. 

Incorporating this data allows us to identify those members who have been served by a PFro, who have also been deemed eligible for a VBP measure. This is taken from the 7/21/23 Health Choice VBP Quality Roster report.

It should be noted that some members are listed more than once on the HC VBPQR for the same measure, sometime with different gap statuses. This inflates the data by 3 cases.

```{r}
#| label: Load and merge VBP data
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

VBPQR <- read.csv("./data/VBPQR_AllAPsCombined_Cleaned_complete_2023-07-21.csv")

# Rename the column 
colnames(VBPQR)[colnames(VBPQR) == "Member.ID"] <- "MemberID"

# Remove the first 3 characters from MemberID and store in a new column AHCCCSID
VBPQR$AHCCCSID <- substr(VBPQR$MemberID, 4, nchar(VBPQR$MemberID))





# Merge PFro Activity and VBPQR, keeping all PFroActivity
PFroActivity <- merge(x = PFroActivity,
                             y = VBPQR,
                             by = "AHCCCSID",
                             all.x = TRUE
                             )

```

Remove...Now we add additional columns to indicate any cases that have been identified by the VBP roster. We record the name of the VBP measure and its gap status per the HC VBPQR.

```{r}
#| label: Append VBP data to table
#| eval: false
#| include: true
#| echo: true
#| warning: false
#| error: false

# # First AMM
# 
# # Create the new columns "isVBP_AMM" and "GapStatus_AMM" with default values
# PFroActivity$isVBP_AMM <- NA
# PFroActivity$GapStatus_AMM <- NA
# 
# # Check for matching MemberID and specific Measure, then assign values to the new columns
# PFroActivity$isVBP_AMM <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & VBPQR$Measure == "AMM - Antidepressant Medication Management - Effective Acute Phase Treatment – Total", "AMM", PFroActivity$isVBP_AMM)
# 
# PFroActivity$GapStatus_AMM <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & VBPQR$Measure == "AMM - Antidepressant Medication Management - Effective Acute Phase Treatment – Total", VBPQR$Gap.Status, PFroActivity$GapStatus_AMM)
# 
# # Then FUH
# 
# # Create the new columns "isVBP_AMM" and "GapStatus_AMM" with default values
# PFroActivity$isVBP_FUH <- NA
# PFroActivity$GapStatus_FUH <- NA
# 
# # Check for matching MemberID and specific Measure, then assign values to the new columns
# PFroActivity$isVBP_FUH <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & VBPQR$Measure == "FUH - Follow-Up after Hospitalization for Mental Illness: 7 Day", "FUH", PFroActivity$isVBP_FUH)
# 
# PFroActivity$GapStatus_FUH <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & VBPQR$Measure == "FUH - Follow-Up after Hospitalization for Mental Illness: 7 Day", VBPQR$Gap.Status, PFroActivity$GapStatus_FUH)
# 
# # Then HDO
# 
# # Create the new columns "isVBP_AMM" and "GapStatus_AMM" with default values
# PFroActivity$isVBP_HDO <- NA
# PFroActivity$GapStatus_HDO <- NA
# 
# # Check for matching MemberID and specific Measure, then assign values to the new columns
# PFroActivity$isVBP_HDO <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & VBPQR$Measure == "HDO - Use of Opioids at High Dosage", "HDO", PFroActivity$isVBP_HDO)
# 
# PFroActivity$GapStatus_HDO <- ifelse(PFroActivity$MemberID %in% VBPQR$MemberID & VBPQR$Measure == "HDO - Use of Opioids at High Dosage", VBPQR$Gap.Status, PFroActivity$GapStatus_HDO)
# 
# # Create the new column "isVBP" with default value "NotVBP"
# PFroActivity$isVBP <- "NotVBP"
# 
# # Check if any of the isVBP_AMM, isVBP_FUH, or isVBP_HDO columns are not NA
# # If any of them is not NA, assign "isVBP" to the "isVBP" column
# PFroActivity$isVBP <- ifelse(!is.na(PFroActivity$isVBP_AMM) | !is.na(PFroActivity$isVBP_FUH) | !is.na(PFroActivity$isVBP_HDO), "isVBP", PFroActivity$isVBP)

```

Next we use the FUH7 Validation (Inpatient Claims) data to check if any of the people identified so far had an eligible FUH7 inpatient claim according to HCA claims that have been approved and paid. The FUH7 data is for claims that were authorized and paid for the measurement year 2023-01-01 to 2023-12-31.

```{r}
#| label: Add inpatient indicator
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

IPClaims <- read_xlsx("./data/data_original_cat_2022-12-31_IPClaims.xlsx")

# Rename the column 
colnames(IPClaims)[colnames(IPClaims) == "AzAhcccsId"] <- "AHCCCSID"

# Assuming PFroActivity and IPClaims are the names of your data frames

# Create a new column in PFroActivity called isIP
PFroActivity <- PFroActivity %>%
  mutate(
    isIP = ifelse(AHCCCSID %in% IPClaims$AHCCCSID, "IPClaim", "NoIP")
        )

```

Next we use the AMM Validation (PBM Claims) data to check if any of the people identified so far had a potentially eligible AMM pharmacy claim according to HCA claims that have been approved and paid. The AMM data is for claims that were authorized and paid for the measurement year Intake Period 2021-05-01 to 2022-04-30.

The AMM Validation model is still under development at the time of this writing. However, the core set of PBMClaims data for antidepressant medications is itself fully valid. Completion of the model will give us more insight, but this is enough to be getting on with.

```{r}
#| label: Add antidepressant med indicator
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

PBMClaims <- read_xlsx("./data/DataRaw_PBMClaims_2022-04-30.xlsx", sheet = "Sheet1")

# Rename the column 
colnames(PBMClaims)[colnames(PBMClaims) == "clientID"] <- "AHCCCSID"

# Create a new column in PFroActivity called isADMed
PFroActivity <- PFroActivity %>%
  mutate(
    isADMed = ifelse(AHCCCSID %in% PBMClaims$AHCCCSID, "ADMedClaim", "NoADMed")
  )

write.csv(PFroActivity, "./data/output/PFroActivity.csv")
```

Finally, we select desired variables from this monster table into the final dataset, called PFroSummary. We also create a separate version with less variables, but filtered for only distinct MemberIDs by provider.

```{r}
#| label: Dial in the data set
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Now select the key variables for analysis
PFroSummary <- PFroActivity |> 
  select(
    AHCCCSID,
    primaryId,
    ra,
    lastName,
    firstName,
    sex,
    dob,
    Age,
    resCountyName,
    zipCode,
    DateOfService,
    svccode,
    Code_Description,
    ProviderName,
    ProviderType,
    Placesvc,
    units,
    AmountPd,
    PrimaryDiagnosis,
    ICD10_Description,
    DiagnosisGroupRange,
    Diagnosis_Group,
    isIP,
    isADMed,
    SubMeasure.ID,
    Gap.Status
    )

# Write to CSV
write.csv(PFroSummary, "./data/output/PFroSummary.csv")

# Create unduplicated roster by provider
PFroSummary_Distinct_byProvider <- PFroSummary %>%
  distinct(AHCCCSID, .keep_all = TRUE)

# Write to CSV
write.csv(PFroSummary_Distinct_byProvider, "./data/output/PFroSummary_Distinct_byProvider.csv")
```

# Analysis

## Figure 1: PFro Services by Provider

The first view of this data is a visualization of the percent of total services delivered to Alliance members by each PFro. This data represents all Alliance Members and all of their PFro services. This was filtered to only include service codes that accounted for at least 1% of the total.

```{r}
#| label: Count PFro Services by Provider
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false


# Calculate the count of svccode by ProviderName
provider_svccode_counts <- PFroSummary %>%
  count(ProviderName, svccode)

# Calculate the grand total count of svccode
grand_total <- sum(provider_svccode_counts$n)

# Calculate the percentage of count for each svccode by ProviderName
provider_svccode_counts <- provider_svccode_counts %>%
  group_by(ProviderName) %>%
  mutate(Percentage = (n / grand_total) * 100)

# Filter to keep only svccodes accounting for at least 1% of the grand total
provider_svccode_counts_filtered <- provider_svccode_counts %>%
  filter(Percentage >= 1)

# Create the chart 
PFro_SvcByProv <- ggplot(provider_svccode_counts_filtered, aes(x = Percentage, y = svccode, fill = ProviderName)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Percent of Total Services by Provider",
       subtitle = "Service Codes less than 1%  removed",
       x = "Percentage", 
       y = "svccode"
       ) +
  theme_minimal() +
  scale_x_continuous(labels = scales::percent_format(scale = 1)) +
  scale_fill_viridis_d()  

## Save Graphics
# Set the file path and name for saving the .png file
Report <- "./data/output/"
Report_Filename <- "2023-07-26_PFro_SvcByProvider.png"

# Save the ggplot as a .png file
# Report
ggsave(file.path(Report, Report_Filename), plot = PFro_SvcByProv, width = 6, height = 4, dpi = 300)

PFro_SvcByProv
```

## Table 1: PFro Services by Provider

The first table is a summary of the services provided, and the amount that was paid to the provider. This data represents all Alliance Members and all of their PFro services. This was filtered to only include service codes that accounted for at least 1% of the total.

```{r}
#| label: First Table
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Assuming PFroSummary is the data frame with columns "Code_Description", "ProviderName", "svccode", "AHCCCSID", and "AmountPd"

# Calculate the count of Code_Description by ProviderName and svccode
code_prov_counts <- PFroSummary %>%
  group_by(Code_Description, ProviderName, svccode) %>%
  tally() %>%
  ungroup()

# Calculate the total count of Code_Description
total_count <- sum(code_prov_counts$n)

# Calculate the percentage of count for each Code_Description
code_prov_counts <- code_prov_counts %>%
  group_by(Code_Description) %>%
  mutate(Percentage_of_Grand_Total = (n / total_count) * 100)

# Filter to keep only Code_Description rows representing at least 1% of the grand total
code_prov_counts_filtered <- code_prov_counts %>%
  filter(Percentage_of_Grand_Total >= 1)

# Reorder the columns to have ProviderName first, followed by svccode
code_prov_counts_filtered <- code_prov_counts_filtered %>%
  select(ProviderName, svccode, Code_Description, Percentage_of_Grand_Total)

# Sort the table by ProviderName in ascending order
code_prov_counts_filtered <- code_prov_counts_filtered %>%
  arrange(ProviderName)

# Summarize the AmountPd column to get the sum of Amount Paid for each Code_Description by ProviderName
amount_paid_sum <- PFroSummary %>%
  filter(Code_Description %in% code_prov_counts_filtered$Code_Description) %>%
  group_by(Code_Description, ProviderName) %>%
  summarise(Sum_AmountPd = sum(AmountPd))

# Join the summarized Amount Paid data with the filtered table
code_prov_counts_filtered <- left_join(code_prov_counts_filtered, amount_paid_sum, by = c("Code_Description", "ProviderName"))

# Format the Percentage_of_Grand_Total column with two decimal places and a "%" symbol
code_prov_counts_filtered$Percentage_of_Grand_Total <- sprintf("%.2f%%", code_prov_counts_filtered$Percentage_of_Grand_Total)

# Format the Sum_AmountPd column with a "$" sign and no decimal places
code_prov_counts_filtered$Sum_AmountPd <- paste0("$", round(code_prov_counts_filtered$Sum_AmountPd, 0))

# Add a column that is a count of distinct AHCCCSID for the given svccode
code_prov_counts_filtered <- code_prov_counts_filtered %>%
  left_join(
    PFroSummary %>%
      group_by(ProviderName, svccode) %>%
      summarise(Distinct_AHCCCSID = n_distinct(AHCCCSID)),
    by = c("ProviderName", "svccode")
  )

## Pick up here. DOn't think too hard.


# Add a column that calculates the average of the Percentage_of_Grand_Total for each unique ProviderName
provider_percentage_avg <- code_prov_counts_filtered %>%
  group_by(ProviderName) %>%
  summarise(Average_Percentage = mean(as.numeric(gsub("%", "", Percentage_of_Grand_Total))))

# Merge the average percentage data with the main table
code_prov_counts_filtered <- left_join(code_prov_counts_filtered, provider_percentage_avg, by = "ProviderName")

# Add a column that is an average of Sum_AmountPd by Distinct_AHCCCSID
code_prov_counts_filtered <- code_prov_counts_filtered %>%
  group_by(Distinct_AHCCCSID) %>%
  mutate(Average_AmountPd = mean(as.numeric(gsub("\\$", "", Sum_AmountPd))))

# Format the Average_AmountPd column with a "$" sign and two decimal places
code_prov_counts_filtered$Average_AmountPd <- paste0("$", format(round(code_prov_counts_filtered$Average_AmountPd, 2), nsmall = 2))

# Rename the columns
code_prov_counts_filtered <- code_prov_counts_filtered %>%
  rename(
    `Provider Name` = ProviderName,
    `Service Code` = svccode,
    `Code Description` = Code_Description,
    `Percent of Grand Total` = Percentage_of_Grand_Total,
    `Amount Paid` = Sum_AmountPd,
    `Members Served` = Distinct_AHCCCSID,
    `Percent of Total` = Average_Percentage,
    `Amount Paid per Person` = Average_AmountPd
  )

# Display the final table using kable
kable(code_prov_counts_filtered, format = "html", caption = "Summary of Services by ProviderName")

```

## Figure 2: PFro Services by Cost

```{r}
#| label: First Plot (beta)
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false


# Calculate the count of svccode by ProviderName
sum_by_provider <- PFroSummary %>%
  group_by(ProviderName, svccode) %>%
  summarise(Total_AmountPd = sum(AmountPd))

# Calculate the grand total count of svccode
grand_total <- sum(sum_by_provider$Total_AmountPd)

# Calculate the pTotal_AmountPdfor each svccode by ProviderName
sum_by_provider <- sum_by_provider %>%
  group_by(ProviderName) %>%
  mutate(Percentage = (Total_AmountPd / grand_total) * 100)

# Filter to keep only svccodes accounting for at least 1% of the grand total
provider_svccode_counts_filtered <- sum_by_provider %>%
  filter(Percentage >= 1)

# Create the chart with svccode on the y-axis and the count as a percentage of the grand total on the x-axis, clustered by ProviderName with custom colors
PFro_AmntPdByProvider <- ggplot(provider_svccode_counts_filtered, aes(x = Percentage, y = svccode, fill = ProviderName)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Amount Paid for PFro Services by Provider",
       subtitle = "As percent of grand total",
       x = "Percent of Amount Paid", 
       y = "svccode") +
  theme_minimal() +
  scale_x_continuous(labels = scales::percent_format(scale = 1)) +
  scale_fill_viridis_d()  # Use the "viridis" color palette for the fill  # Use custom colors for the fill# Rotate x-axis labels at 45 degrees

## Create Graphics
# Set the file path and name for saving the .png file
Report <- "./data/output/"
Report_Filename <- "2023-07-26_PFro_AmtPdByProvider.png"

# Save the ggplot as a .png file
# Report
ggsave(file.path(Report, Report_Filename), plot = PFro_AmntPdByProvider, width = 6, height = 4, dpi = 300)

PFro_AmntPdByProvider
```

## Figure 3: PFro Member Engagement

The following figure assesses the number of HCA members in services with a PFro that have been deemed eligible for a VBP measure. For this assessment, T1016 (Case Management) was excluded.

```{r}
#| label: Distinct Members
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Assuming PFroSummary is your data frame

# Calculate the count of distinct MemberID for each ProviderName and isVBP combination
stacked_data <- PFroSummary %>%
  filter(svccode != "T1016") |>
  group_by(ProviderName, isVBP) %>%
  summarise(count = n_distinct(MemberID))

# Calculate the grand total
grand_total <- sum(stacked_data$count)

# Add a column for the percent of grand total
stacked_data <- stacked_data %>%
  mutate(Percent_of_Grand_Total = (count / grand_total) * 100)

PFro_VBPMemberEngagement <- ggplot(stacked_data, aes(x = count, y = ProviderName, fill = isVBP)) +
  geom_bar(stat = "identity") +
  labs(title = "Current PFro Engagement with VBP Eligible Members",
       x = "Count of Distinct MemberID",
       y = "ProviderName",
       fill = "VBP Eligibility",
       caption = "T1016 Suppressed") +
  theme_minimal() +
  theme(axis.text.x.top = element_text(hjust = 0),
        axis.title.y = element_blank(),
        plot.title = element_text(hjust = .75),
        plot.subtitle = element_text(hjust = 30)
        ) + 
  scale_fill_manual(values = c("#FFA500", "#000080"))  # Use custom colors for the fill

## Create Graphics
# Set the file path and name for saving the .png file
Report <- "./data/output/"
Report_Filename <- "2023-07-26_PFro_VBPMemberEngagement.png"

# Save the ggplot as a .png file
# Report
ggsave(file.path(Report, Report_Filename), plot = PFro_VBPMemberEngagement, width = 6, height = 4, dpi = 300)

PFro_VBPMemberEngagement

```

## Table 2: PFro Member Engagement

```{r}
#| label: Second Table
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Filter out rows where svccode is "T1016"
PFroSummary_filtered <- PFroSummary %>%
  filter(svccode != "T1016")

# Calculate the count of distinct MemberID for each ProviderName and isVBP combination
summary_table <- PFroSummary_filtered %>%
  group_by(ProviderName, isVBP) %>%
  summarise(Count_of_Distinct_MemberID = n_distinct(MemberID)) %>%
  ungroup() %>%
  group_by(ProviderName) %>%
  mutate(Total_by_Provider = sum(Count_of_Distinct_MemberID),
         `Percent of Total per Provider` = (Count_of_Distinct_MemberID / Total_by_Provider) * 100) %>%
  select(-Total_by_Provider) # Remove the intermediate column

# Format the "Percent of Total per Provider" column to have 2 decimal places
summary_table$`Percent of Total per Provider` <- sprintf("%.2f%%", summary_table$`Percent of Total per Provider`)

# Calculate the grand total
grand_total <- n_distinct(PFroSummary_filtered$MemberID)

# Calculate the percent of grand total for each ProviderName
summary_table$`Percent of Grand Total` <- sprintf("%.2f%%", (summary_table$Count_of_Distinct_MemberID / grand_total) * 100)

kable(summary_table)


```

## Figure 4: PFro Member Engagement by County

```{r}
#| label: County
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Filter out rows where svccode is "T1016"
PFroSummary_filtered <- PFroSummary %>%
  filter(svccode != "T1016")

# Create a summary table by resCountyName and ProviderName
summary_table <- PFroSummary_filtered %>%
  group_by(resCountyName, ProviderName) %>%
  summarise(Count_of_Distinct_MemberID = n_distinct(MemberID)) %>%
  ungroup()

# Sort the resCountyName based on the count of MemberIDs in descending order
summary_table <- summary_table %>%
  arrange(resCountyName, desc(Count_of_Distinct_MemberID))

# Create the stacked bar chart with flipped axes and sorted bars
PFro_AllMemberEngagementByCounty <- ggplot(data = summary_table, aes(x = fct_reorder(resCountyName, Count_of_Distinct_MemberID, .fun = sum), y = Count_of_Distinct_MemberID, fill = ProviderName)) +
  geom_bar(stat = "identity") +
  labs(title = "Member Engagement by County and Provider",
       subtitle = "T1016 Removed",
       x = "County",
       y = "Number of MemberIDs") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        axis.title = element_blank()
        ) +
  guides(fill = guide_legend(title = "Provider Name")) +
  scale_fill_viridis_d()+  # Use the "viridis" color palette for the fill
  coord_flip()

## Create Graphics
# Set the file path and name for saving the .png file
Report <- "./data/output/"
Report_Filename <- "2023-07-26_PFro_AllMemberEngagementByCounty.png"

# Save the ggplot as a .png file
# Report
ggsave(file.path(Report, Report_Filename), plot = PFro_AllMemberEngagementByCounty, width = 6, height = 4, dpi = 300)

PFro_AllMemberEngagementByCounty

```

## Figure 5: Population Pyramid

```{r}
#| label: SexByAgeGroup
#| include: true
#| echo: true
#| warning: false
#| error: false

# Create the table for the Population Pyramid
DemoTable_SexByAgeGroup <- PFroSummary_Distinct_byProvider |> 
  select(Age, sex) |> 
  mutate(`00 - 05` = case_when(
    Age > 00 & Age <= 5 ~ "1", TRUE ~ "0")) |>
  mutate(`06 - 12` = case_when(
    Age > 06 & Age <= 12 ~ "1", TRUE ~ "0")) |> 
  mutate(`13 - 17` = case_when(
    Age > 13 & Age <= 17 ~ "1", TRUE ~ "0")) |> 
  mutate(`18 - 34` = case_when(
    Age > 18 & Age <= 34 ~ "1", TRUE ~ "0")) |> 
  mutate(`35 - 64` = case_when(
    Age > 35 & Age <= 64 ~ "1", TRUE ~ "0")) |> 
  mutate(`65 - 99` = case_when(
    Age > 65  ~ "1", TRUE ~ "0")) |> 
  subset(select = -Age) |> 
  #covert to dbl
  mutate(`00 - 05` = as.numeric(`00 - 05`)) |>  
  mutate(`06 - 12` = as.numeric(`06 - 12`)) |> 
  mutate(`13 - 17` = as.numeric(`13 - 17`)) |> 
  mutate(`18 - 34` = as.numeric(`18 - 34`)) |> 
  mutate(`35 - 64` = as.numeric(`35 - 64`)) |> 
  mutate(`65 - 99` = as.numeric(`65 - 99`)) |> 
  #Group by sex and summarize
  group_by(sex) |> 
  summarise_if(is.numeric, sum, na.rm = TRUE) |> 
  pivot_longer(!sex, 
               names_to = "Age_Group",
               values_to = "n") |> 
  # Change "M" "F" to "Male" "Female"
  mutate(sex = case_when(
    sex == "M" ~ "Male",
    sex == "F" ~ "Female"
  )) |> 
  #change male to negative so it flips sides of the axis on a shared facet plot
  mutate(n = ifelse(sex == "Male", n * -1, n)) |> 
  #change male female to factor
  mutate(sex = factor(sex, levels = c("Male","Female")))

# Export the table as a csv for reference, Date is date of progress report
write.csv(DemoTable_SexByAgeGroup, "./data/output/2023-07-26_DemoTable_SexByAgeGroup.csv")


```

```{r}
#| label: Graphic_SexByAgeGroup_Pyramid
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

Fig_PopPyramid <- ggplot(DemoTable_SexByAgeGroup, aes(x = n, y = reorder(Age_Group, n), fill = sex)) +
  geom_bar(stat = "identity", position = "identity") +
  geom_text(aes(label = abs(n), hjust = ifelse(sex == "Female", -0.2, 1.2)), size = 3) +
  scale_fill_manual(values = c(Female = "#FFA500", Male = "#000080")) +
  facet_wrap(~ sex, scales = "free") +
  labs(
    x = NULL, 
    y = NULL, 
    fill = "Member Sex",
    title = "PFro Member Engagement by Gender and Age Group",
    subtitle = "July 27, 2023",
    caption = "Source: BCBSAZ Global Members, Extracted 2023-07-26")  +
  theme_classic() +
  theme(
    axis.text.y.right = element_text(margin = margin(0, 2.2, 0, 2.2)),
    legend.position = "bottom", 
    legend.justification = "center",
    panel.spacing.x = unit(0, "pt"))

## Create Graphics
# Set the file path and name for saving the .png file
Report <- "./data/output/"
Report_Filename <- "2023-07-26_PFro_PopPyramid.png"

# Save the ggplot as a .png file
# Report
ggsave(file.path(Report, Report_Filename), plot = Fig_PopPyramid, width = 6, height = 4, dpi = 300)

Fig_PopPyramid

```

## Table 5: PFroEngagement Matrix

This table summarizes all of the combinations of PFro Status and VBP Status.

```{r}
#| label: PFro Engagement Matrix
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Import the Global Members Roster of non duplicated list of distinct AHCCCSIDs
PFroEngagementMatrix <- as_tibble(NAZMmbrshp$AHCCCSID)

# If a Global Member AHCCCSID matches a PFro Member AHCCCSID, then return the "isVBP" value from the PFroSummary, if it does not match, return "NoPFro"
PFroEngagementMatrix$isVBP <- ifelse(NAZMmbrshp$AHCCCSID %in% PFroSummary_Distinct_byProvider$AHCCCSID, PFroSummary_Distinct_byProvider$isVBP, "NoPFroServices")

# Replace values in the "isVBP" column
PFroEngagementMatrix$isVBP[PFroEngagementMatrix$isVBP == "isVBP"] <- "Member on VBP Roster"
PFroEngagementMatrix$isVBP[PFroEngagementMatrix$isVBP == "NotVBP"] <- "Member Not on VBP Roster"

# Did they have PFro Services
PFroEngagementMatrix$isPFro <- ifelse(NAZMmbrshp$AHCCCSID %in% PFroSummary_Distinct_byProvider$AHCCCSID, "PFroServices", "NoPFroServices") 

PFroEngagementMatrix %>%
  group_by(isVBP, isPFro) %>%
  summarise(Count = n())

# Assuming you have a data frame named 'your_table' with columns "value", "isVBP", and "isPFro"

# Group the data by "isVBP" and "isPFro" and then count the occurrences of each combination
PFroEngagementSummary <- PFroEngagementMatrix %>%
  group_by(isVBP, isPFro) %>%
  summarise(Count = n())

write.csv(PFroEngagementMatrix, "./data/output/PFroEngagementMatrix.csv")

# Rename the columns
colnames(PFroEngagementSummary) <- c("Included_In_VBPMeasure", "Received_PFroService", "n")

write.csv(PFroEngagementSummary, "./data/output/PFroEngagementSummary.csv")

kable(PFroEngagementSummary)
```
## PFro Involvement in VBP Measures

### Figure 6

```{r}
#| label: Graphic_PFroMemberEngagement
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Assuming your_table is the data frame with columns "Included_In_VBPMeasure", "Received_PFroService", and "n"

# Calculate the percentage of the grand total for each combination
PFroEngagementSummary$Percentage <- PFroEngagementSummary$n / sum(PFroEngagementSummary$n) * 100

# Create a bar plot with percentage of the grand total and x-axis labels at 45-degree angle
PFro_InvlvmtWithVBPMeasures <- ggplot(PFroEngagementSummary, aes(x = Included_In_VBPMeasure, y = Percentage, fill = Received_PFroService)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = paste0(round(Percentage, 3), "%")), 
            position = position_dodge(width = 0.9), 
            vjust = -0.5, 
            size = 3.5
  ) + 
  labs(title = "PFro Involvement With VBP Measures",
       subtitle = "By Members Found on Health Choice VBP Roster"
       ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) +  # Format y-axis as percentage
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title = element_blank()
        )+
  scale_fill_viridis_d()  # Use the "viridis" color palette for the fill  # Use custom colors for the fill# Rotate x-axis labels at 45 degrees

## Create Graphics
# Set the file path and name for saving the .png file
Report <- "./data/output/"
Report_Filename <- "2023-07-26_PFro_InvlvmtWithVBPMeasures.png"

# Save the ggplot as a .png file
# Report
ggsave(file.path(Report, Report_Filename), plot = PFro_InvlvmtWithVBPMeasures, width = 6, height = 4, dpi = 300)

PFro_InvlvmtWithVBPMeasures
```

### Table 6: PFro Engagement With VBP Members

This table is a list of actively enrolled Alliance Members, who are listed on the Health Choice VBP Quality Roster, who have received services from a PFro, and all of the indicators by claim from the PFroSummary.

```{r}
#| label: PFroEngagementWithVBPMmbrs
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

# Filter the matrix for only individuals on VBP Roster
PFroEngagementWithVBPMmbrs <- PFroEngagementMatrix |> 
  filter(isVBP == "Member on VBP Roster")

# Rename the column 
colnames(PFroEngagementWithVBPMmbrs)[colnames(PFroEngagementWithVBPMmbrs) == "value"] <- "AHCCCSID"

PFroEngagementWithVBPMmbrs <- merge(x = PFroEngagementWithVBPMmbrs,
                                    y = PFroSummary,
                                    by = "AHCCCSID",
                                    all.x = TRUE
)

PFroEngagementWithVBPMmbrs <- PFroEngagementWithVBPMmbrs |> 
  rename(AHCCCSID = AHCCCSID,
         `On VBPQR Roster` = isVBP.x,
         `Received PFro Svc` = isPFro,
         MemberID = MemberID,
         PrimaryId = primaryId,
         `Alliance Provider` = ra,
         `Last names` = lastName,
         `First Name` = firstName,
         `Sex` = sex,
         `Date of Birth` = dob,
         `Mmbr Cnty of Residence` = resCountyName,
         `Mmbr Zip Code` = zipCode,
         `Date of Service` = DateOfService,
         `Service Code` = svccode,
         `Code Description` = Code_Description,
         `Alliance PFro Provider` = ProviderName,
         `Provider Type` = ProviderType,
         `Place of Service` = Placesvc,
         `Units` = units,
         `Amount Paid` = AmountPd,
         `Primary Diagnosis` = PrimaryDiagnosis, 
         `ICD10 Dx Description` = ICD10_Description,
         `ICD10 Dx Group Range` = DiagnosisGroupRange,
         `ICD10 Dx Group` = Diagnosis_Group,
         `On VBPQR Roster.y` = isVBP.y,
         `AMM Roster` = isVBP_AMM,
         `AMM Gap Status` = GapStatus_AMM,
         `FUH Roster` = isVBP_FUH,
         `FUH Gap Status` = GapStatus_FUH,
         `HDO Roster` = isVBP_HDO,
         `HDO Gap Status` = GapStatus_HDO,
         `Validated FUH Inpatient Svc` = isIP,
         `Validated AMM Pharmacy Svc` = isADMed
         )

write.csv(PFroEngagementWithVBPMmbrs, "./data/output/PFroEngagementWithVBPMembers.csv")

```

### Figure 7:
```{r}
#| label: Graphic_PFro Engagement With VBP Members
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false


# Calculate the count of svccode by ProviderName
provider_svccode_counts <- PFroEngagementWithVBPMmbrs %>%
  count(`Alliance PFro Provider`, `Service Code`)

# Calculate the grand total count of svccode
grand_total <- sum(provider_svccode_counts$n)

# Calculate the percentage of count for each svccode by ProviderName
provider_svccode_counts <- provider_svccode_counts %>%
  group_by(`Alliance PFro Provider`) %>%
  mutate(Percentage = (n / grand_total) * 100)

# Filter to keep only svccodes accounting for at least 1% of the grand total
provider_svccode_counts_filtered <- provider_svccode_counts %>%
  filter(Percentage >= 1)

# Create the chart with svccode on the y-axis and the count as a percentage of the grand total on the x-axis, clustered by ProviderName with custom colors
Graphic_PFroEngagementWithVBPMmbrs <- ggplot(provider_svccode_counts_filtered, aes(x = Percentage, y = `Service Code`, fill = `Alliance PFro Provider`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "PFro Engagement With VBP Members",
       subtitle = "As percent of grand total",
       x = "Percent of Total Services", 
       y = "Service Code") +
  theme_minimal() +
  scale_x_continuous(labels = scales::percent_format(scale = 1))+
  scale_fill_viridis_d()  # Use the "viridis" color palette for the fill  # Use custom colors for the fill# Rotate x-axis labels at 45 degrees 

## Create Graphics
# Set the file path and name for saving the .png file
Report <- "./data/output/"
Report_Filename <- "2023-07-26_PFro_EngagementWithVBPMmbrs.png"

# Save the ggplot as a .png file
# Report
ggsave(file.path(Report, Report_Filename), plot = Graphic_PFroEngagementWithVBPMmbrs, width = 6, height = 4, dpi = 300)

Graphic_PFroEngagementWithVBPMmbrs
```

### Figure 8: Gap Status of Member with PFro Services

To be continued...

```{r}
#| label: Gap Status of Member with PFro Services
#| eval: true
#| include: true
#| echo: true
#| warning: false
#| error: false

GapStatusWithPFroSvcs <- PFroEngagementWithVBPMmbrs |> 
  select(
    AHCCCSID,
    `AMM Roster`,
    `AMM Gap Status`
    ) |> 
  filter(!is.na(`AMM Roster`))


```